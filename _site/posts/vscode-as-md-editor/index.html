<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.554">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2023-03-02">

<title>For the Wynn - VSCode as an MD Editor</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">For the Wynn</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../me.html"> 
<span class="menu-text">David Wynn</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com/DavidBWynn"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/FTWynn"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">VSCode as an MD Editor</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Technology</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 2, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>So <a href="https://fosstodon.org/@kev">Kev</a> <a href="https://kevquirk.com/my-static-site-workflow/">made a post</a> about how <a href="https://typora.io/">Typora</a> was the missing UI link in his static site blogging journey.</p>
<p>https://kevquirk.com/my-static-site-workflow/</p>
<p>It got me thinking… can’t <a href="https://code.visualstudio.com/">VSCode</a> do all that? Is that the linchpin I’ve been missing in my blogging workflow? Time to see if I can recreate his process and tweak it for myself!</p>
<!--more-->
<section id="replicating-success" class="level2">
<h2 class="anchored" data-anchor-id="replicating-success">Replicating Success</h2>
<section id="inserting-links-with-a-keyboard-shortcut" class="level3">
<h3 class="anchored" data-anchor-id="inserting-links-with-a-keyboard-shortcut">Inserting links with a Keyboard Shortcut</h3>
<p>To quote Kev’s steps:</p>
<ol type="1">
<li>Search for the post/page on my live site that I want to link to</li>
<li>Copy the link to the post from the results</li>
<li>Highlight the text I want to link to in Typora</li>
<li>Hit ⌘ + K</li>
</ol>
<p>Assuming search is the easy part (the fallback is just DuckDuckGo with a <code>site:</code> param), the pasting with auto-formatting is the key part.</p>
<p>For VSCode there’s a <a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">big extension</a> that does this, and a <a href="https://marketplace.visualstudio.com/items?itemName=mdickin.markdown-shortcuts">small one</a>. I installed the big one because it had more downloads. Looks good so far, even using the normal <code>ctrl + v</code> shortcut so I don’t have to think when pasting.</p>
<p>I’ve found, even when just writing this post, this makes me much more generous with linking out to other sites when writing.</p>
</section>
<section id="previewing-posts" class="level3">
<h3 class="anchored" data-anchor-id="previewing-posts">Previewing Posts</h3>
<p>This one has two options in VSCode, but first, let’s recreate what’s working for Kev in Typora.</p>
<p>VSCode allows you to style the built-in Markdown preview with either local css files or ones from any URL. I opted to make a new css file and add it to the repo so I could keep the local preview local.</p>
<p>I discovered, like Kev did, it’s not really possible to entirely recreate the website (until I found something I’ll mention in a second), so some cherry picking was needed to recreate the style. Sadly, my site uses a bunch of scss, which the VSCode Markdown preview doesn’t support. So I went through my live website, inspecting the generated css rules and copying them into the new css file by hand. It only took a handful of stylings for <code>body</code>, <code>p</code>, <code>code</code>, <code>h2</code>, <code>h3</code>, and <code>blockquote</code> before I was basically there.</p>
<p>But then… I found something truly impressive. Something at the bottom of the <a href="https://gohugo.io/tools/editors/#visual-studio-code">Hugo Editors documentation</a> that I wish I’d had for a while…</p>
<p>https://frontmatter.codes/</p>
<p>Oh. Ooooohhh…..</p>
<p>That’s a whole CMS entirely implemented as an extension. It’s based on front matter (hence the name) and works with multiple static site generators. That’s… exactly what I’ve wanted but didn’t dare to hope for.</p>
<p>In addition to easy buttons to start the local server, it will display the whole, live website in a VSCode preview window instead of a basic css approximation.</p>
<p>To be fair, there is a downside. Namely, it doesn’t update as you type (only on save), and it remembers your scroll position rather than jumps to where the cursor is, but for all the extra CMS features (I can coherently keep draft posts in the repo now!), it seems like quite a bargain.</p>
<p>You can also still use the built-in preview window if you prefer. No need to commit to one or the other.</p>
</section>
<section id="drag-and-drop-an-image-to-the-a-target-folder" class="level3">
<h3 class="anchored" data-anchor-id="drag-and-drop-an-image-to-the-a-target-folder">Drag and Drop an Image to the a Target Folder</h3>
<p>I’m afraid I might be stumped on the drag and drop piece in attempting to be 1 for 1 with Typora. No one seems to have made an extension that brings an image file <em>in</em> to the current project by dragging it into the editor window. Everything seems to add a link to wherever the file already is, local or URL. In that sense, you’d have to go to his old method of putting the file in the correct folder first.</p>
<p>You can, however, open the media page in Front Matter and drag and drop it there. It’ll end up in the right folder, and you can even copy the relative URL from there. So it’s close… but not quite the same.</p>
<p>Perhaps more interestingly, you can <a href="https://frontmatter.codes/docs/custom-actions#creating-a-media-script">run a script on the image folder</a> from Front Matter, potentially removing that optimization step through the context click entirely. The docs <a href="https://frontmatter.codes/docs/custom-actions#optimize-image-(media-file-script)">have an example</a> for just that.</p>
<p>But rather than set that up, I found <a href="https://github.com/Tichau/FileConverter">File Converter</a> for doing context menu conversions which I installed with <a href="https://chocolatey.org/">Chocolatey</a>. If I find myself out and about away from my Windows machine, I don’t see a reason not to use <a href="https://cloudconvert.com/webp-converter">CloudConvert</a> on my Chromebook or Mac or otherwise in a pinch.</p>
<p>Frankly, I don’t use a lot of images, and if I did I’d want to lean into object storage like Cloudflare’s R2 to serve them, which is not nearly so well integrated into VSCode. But that’s a project for another day. Maybe when I finally get around to that podcast I’ve been meaning to do and I don’t want 100’s of MBs of mp3 sitting in Github.</p>
<p>There’s probably a way to auto-optimize any images dropped into a folder, which then rsync’s to the bucket… but no! Another day!</p>
</section>
<section id="publishing-with-a-single-command" class="level3">
<h3 class="anchored" data-anchor-id="publishing-with-a-single-command">Publishing with a Single Command</h3>
<p>I use Cloudflare Pages to host this website, which is an awesome product. I was on Google Cloud Storage for a while (as the archive shows), but the http serving there is a bit of an afterthought. Pages has a lot of nice quality of life features around https (and CNAME flattening if you use their DNS as well) that you’d have to build yourself on GCP or AWS. It’s clear that small, static-style apps is Cloudflare Pages’ target… and it works beautifully.</p>
<p>In the case of my blog, it automatically pulls from the Github when I commit a post. So in VSCode I just push sync, and it’s done. Couldn’t be easier.</p>
<p>Pages also stores several deployments back, so if anything gets broken, I can revert to an old version easily while I dig in and fix it.</p>
</section>
</section>
<section id="free-extras-from-using-vscode" class="level2">
<h2 class="anchored" data-anchor-id="free-extras-from-using-vscode">Free Extras from Using VSCode</h2>
<section id="deep-git-integration" class="level3">
<h3 class="anchored" data-anchor-id="deep-git-integration">Deep Git Integration</h3>
<p>VSCode is a programmer’s editor, and naturally comes with all the git tools that you would expect tightly integrated into the GUI. Especially as I was selecting and tweaking my theme, I found it incredibly helpful to stage different files in different commits… because rolling back layout-breaking changes to my site shouldn’t require losing content commits as well.</p>
</section>
<section id="find-across-files-is-really-good" class="level3">
<h3 class="anchored" data-anchor-id="find-across-files-is-really-good">Find Across Files is <em>Really</em> Good</h3>
<p>I’m constantly looking for something in another file it seems, and VSCode is always there with just what I need. Never mind that it also makes search and replace with regex super easy, which I used to great effect recently when renaming some categories across all my posts.</p>
</section>
<section id="its-on-all-my-platforms" class="level3">
<h3 class="anchored" data-anchor-id="its-on-all-my-platforms">It’s on All my Platforms</h3>
<p>I mentioned it earlier, but I routinely rotate between Windows, Mac, Linux, and Chromebook as I move around… and VSCode is there for me on every platform. Coupled with Git push and pull, I’ve got a local environment where I can push new content no matter where I am. It’s great to be that flexible.</p>
</section>
</section>
<section id="conclusion-its-viable" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-its-viable">Conclusion: It’s Viable!</h2>
<p>I think the biggest weakness with the setup is the spell checking. It’s a touch hit or miss, missing some small words like “ot”. But overall, I’m more at home in a techy feeling editor anyway, and I hope Front Matter is enough to get Kev to reconsider his setup all over again. ;-)</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>